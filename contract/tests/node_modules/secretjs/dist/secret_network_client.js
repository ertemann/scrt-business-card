"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxResultCode = exports.gasToFee = exports.SecretNetworkClient = exports.ReadonlySigner = exports.BroadcastMode = void 0;
const encoding_1 = require("@cosmjs/encoding");
const grpc_web_1 = require("@improbable-eng/grpc-web");
const grpc_web_node_http_transport_1 = require("@improbable-eng/grpc-web-node-http-transport");
const _1 = require(".");
const encryption_1 = require("./encryption");
const permit_signer_1 = require("./extensions/access_control/permit/permit_signer");
const msgs_1 = require("./extensions/access_control/viewing_key/msgs");
const snip20_1 = require("./extensions/snip20");
const snip721_1 = require("./extensions/snip721");
const query_1 = require("./query");
const tx_1 = require("./tx");
const wallet_amino_1 = require("./wallet_amino");
var BroadcastMode;
(function (BroadcastMode) {
    /**
     * Broadcast transaction to mempool and wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */
    BroadcastMode["Sync"] = "Sync";
    /**
     * Broadcast transaction to mempool and do not wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */
    BroadcastMode["Async"] = "Async";
})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));
class ReadonlySigner {
    getAccounts() {
        throw new Error("getAccounts() is not supported in readonly mode.");
    }
    signAmino(_signerAddress, _signDoc) {
        throw new Error("signAmino() is not supported in readonly mode.");
    }
}
exports.ReadonlySigner = ReadonlySigner;
class SecretNetworkClient {
    constructor(grpc, txService, query, msgDecoderRegistry, options) {
        var _a, _b;
        this.txService = txService;
        this.query = query;
        this.query.getTx = (hash) => this.getTx(hash);
        this.query.txsQuery = (query) => this.txsQuery(query);
        if (options.wallet && options.walletAddress === undefined) {
            throw new Error("Must also pass 'walletAddress' when passing 'wallet'");
        }
        this.wallet = (_a = options.wallet) !== null && _a !== void 0 ? _a : new ReadonlySigner();
        this.address = (_b = options.walletAddress) !== null && _b !== void 0 ? _b : "";
        this.chainId = options.chainId;
        this.utils = { accessControl: { permit: new permit_signer_1.PermitSigner(this.wallet) } };
        this.msgDecoderRegistry = msgDecoderRegistry;
        // TODO fix this any
        const doMsg = (msgClass) => {
            const func = (params, options) => {
                return this.tx.broadcast([new msgClass(params)], options);
            };
            func.simulate = (params, options) => {
                return this.tx.simulate([new msgClass(params)], options);
            };
            return func;
        };
        this.tx = {
            broadcast: this.signAndBroadcast.bind(this),
            simulate: this.simulate.bind(this),
            snip20: {
                send: doMsg(snip20_1.MsgSnip20Send),
                transfer: doMsg(snip20_1.MsgSnip20Transfer),
                increaseAllowance: doMsg(snip20_1.MsgSnip20IncreaseAllowance),
                decreaseAllowance: doMsg(snip20_1.MsgSnip20DecreaseAllowance),
                setViewingKey: doMsg(msgs_1.MsgSetViewingKey),
                createViewingKey: doMsg(msgs_1.MsgCreateViewingKey),
            },
            snip721: {
                send: doMsg(snip721_1.MsgSnip721Send),
                mint: doMsg(_1.MsgSnip721Mint),
                addMinter: doMsg(_1.MsgSnip721AddMinter),
                setViewingKey: doMsg(msgs_1.MsgSetViewingKey),
                createViewingKey: doMsg(msgs_1.MsgCreateViewingKey),
            },
            authz: {
                exec: doMsg(_1.MsgExec),
                grant: doMsg(_1.MsgGrant),
                revoke: doMsg(_1.MsgRevoke),
            },
            bank: {
                multiSend: doMsg(_1.MsgMultiSend),
                send: doMsg(_1.MsgSend),
            },
            compute: {
                executeContract: doMsg(_1.MsgExecuteContract),
                instantiateContract: doMsg(_1.MsgInstantiateContract),
                storeCode: doMsg(_1.MsgStoreCode),
            },
            crisis: {
                verifyInvariant: doMsg(_1.MsgVerifyInvariant),
            },
            distribution: {
                fundCommunityPool: doMsg(_1.MsgFundCommunityPool),
                setWithdrawAddress: doMsg(_1.MsgSetWithdrawAddress),
                withdrawDelegatorReward: doMsg(_1.MsgWithdrawDelegatorReward),
                withdrawValidatorCommission: doMsg(_1.MsgWithdrawValidatorCommission),
            },
            evidence: {
                submitEvidence: doMsg(_1.MsgSubmitEvidence),
            },
            feegrant: {
                grantAllowance: doMsg(_1.MsgGrantAllowance),
                revokeAllowance: doMsg(_1.MsgRevokeAllowance),
            },
            gov: {
                deposit: doMsg(_1.MsgDeposit),
                submitProposal: doMsg(_1.MsgSubmitProposal),
                vote: doMsg(_1.MsgVote),
                voteWeighted: doMsg(_1.MsgVoteWeighted),
            },
            ibc: {
                transfer: doMsg(_1.MsgTransfer),
            },
            slashing: {
                unjail: doMsg(_1.MsgUnjail),
            },
            staking: {
                beginRedelegate: doMsg(_1.MsgBeginRedelegate),
                createValidator: doMsg(_1.MsgCreateValidator),
                delegate: doMsg(_1.MsgDelegate),
                editValidator: doMsg(_1.MsgEditValidator),
                undelegate: doMsg(_1.MsgUndelegate),
            },
        };
        if (options.encryptionUtils) {
            this.encryptionUtils = options.encryptionUtils;
        }
        else {
            this.encryptionUtils = new encryption_1.EncryptionUtilsImpl(this.query.registration, options.encryptionSeed, this.chainId);
        }
        // Reinitialize ComputeQuerier with a shared EncryptionUtils (better caching, same seed)
        this.query.compute = new query_1.ComputeQuerier(grpc, this.encryptionUtils);
    }
    /** Creates a new SecretNetworkClient client. For a readonly client pass just the `grpcUrl` param. */
    static create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { GrpcWebImpl } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/secret/compute/v1beta1/query")));
            let grpcWeb;
            options.grpcWebUrl = options.grpcWebUrl.replace(/\/*$/, ""); // remove trailing slash
            if (typeof window === "undefined") {
                // node.js
                grpcWeb = new GrpcWebImpl(options.grpcWebUrl, {
                    transport: (0, grpc_web_node_http_transport_1.NodeHttpTransport)(),
                    // debug: true,
                });
            }
            else {
                // browser
                grpcWeb = new GrpcWebImpl(options.grpcWebUrl, {
                    transport: grpc_web_1.grpc.CrossBrowserHttpTransport({ withCredentials: false }),
                    // debug: true,
                });
            }
            const { ServiceClientImpl } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/service")));
            const txService = new ServiceClientImpl(grpcWeb);
            const query = {
                auth: new query_1.AuthQuerier(grpcWeb),
                authz: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/authz/v1beta1/query")))).QueryClientImpl(grpcWeb),
                bank: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/bank/v1beta1/query")))).QueryClientImpl(grpcWeb),
                compute: new query_1.ComputeQuerier(grpcWeb),
                snip20: new snip20_1.Snip20Querier(grpcWeb),
                snip721: new snip721_1.Snip721Querier(grpcWeb),
                distribution: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/distribution/v1beta1/query")))).QueryClientImpl(grpcWeb),
                evidence: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/evidence/v1beta1/query")))).QueryClientImpl(grpcWeb),
                feegrant: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/feegrant/v1beta1/query")))).QueryClientImpl(grpcWeb),
                gov: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/gov/v1beta1/query")))).QueryClientImpl(grpcWeb),
                ibc_channel: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/ibc/core/channel/v1/query")))).QueryClientImpl(grpcWeb),
                ibc_client: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/ibc/core/client/v1/query")))).QueryClientImpl(grpcWeb),
                ibc_connection: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/ibc/core/connection/v1/query")))).QueryClientImpl(grpcWeb),
                ibc_transfer: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/ibc/applications/transfer/v1/query")))).QueryClientImpl(grpcWeb),
                mint: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/mint/v1beta1/query")))).QueryClientImpl(grpcWeb),
                params: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/params/v1beta1/query")))).QueryClientImpl(grpcWeb),
                registration: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/secret/registration/v1beta1/query")))).QueryClientImpl(grpcWeb),
                slashing: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/slashing/v1beta1/query")))).QueryClientImpl(grpcWeb),
                staking: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/staking/v1beta1/query")))).QueryClientImpl(grpcWeb),
                tendermint: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/base/tendermint/v1beta1/query")))).ServiceClientImpl(grpcWeb),
                upgrade: new (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/upgrade/v1beta1/query")))).QueryClientImpl(grpcWeb),
                getTx: () => __awaiter(this, void 0, void 0, function* () { return null; }),
                txsQuery: () => __awaiter(this, void 0, void 0, function* () { return []; }), // stub until we can set this in the constructor
            };
            const msgDecoderRegistry = yield (0, tx_1.getMsgDecoderRegistry)();
            return new SecretNetworkClient(grpcWeb, txService, query, msgDecoderRegistry, options);
        });
    }
    getTx(hash, nonces = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.txsQuery(`tx.hash='${hash}'`, nonces);
            return (_a = results[0]) !== null && _a !== void 0 ? _a : null;
        });
    }
    txsQuery(query, nonces = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { txResponses } = yield this.txService.getTxsEvent({
                events: query.split(" AND ").map((q) => q.trim()),
            });
            return yield Promise.all(txResponses.map((tx) => __awaiter(this, void 0, void 0, function* () {
                let rawLog = tx.rawLog;
                let jsonLog;
                let arrayLog;
                if (tx.code === 0 && rawLog !== "") {
                    jsonLog = JSON.parse(rawLog);
                    arrayLog = [];
                    for (let msgIndex = 0; msgIndex < jsonLog.length; msgIndex++) {
                        if (jsonLog[msgIndex].msg_index === undefined) {
                            jsonLog[msgIndex].msg_index = msgIndex;
                            // See https://github.com/cosmos/cosmos-sdk/pull/11147
                        }
                        const log = jsonLog[msgIndex];
                        for (const event of log.events) {
                            for (const attr of event.attributes) {
                                // Try to decrypt
                                if (event.type === "wasm") {
                                    const nonce = nonces[msgIndex];
                                    if (nonce && nonce.length === 32) {
                                        try {
                                            attr.key = (0, encoding_1.fromUtf8)(yield this.encryptionUtils.decrypt((0, encoding_1.fromBase64)(attr.key), nonce)).trim();
                                        }
                                        catch (e) { }
                                        try {
                                            attr.value = (0, encoding_1.fromUtf8)(yield this.encryptionUtils.decrypt((0, encoding_1.fromBase64)(attr.value), nonce)).trim();
                                        }
                                        catch (e) { }
                                    }
                                }
                                arrayLog.push({
                                    msg: msgIndex,
                                    type: event.type,
                                    key: attr.key,
                                    value: attr.value,
                                });
                            }
                        }
                    }
                }
                else if (tx.code !== 0 && rawLog !== "") {
                    try {
                        const errorMessageRgx = /; message index: (\d+): encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;
                        const rgxMatches = errorMessageRgx.exec(rawLog);
                        if ((rgxMatches === null || rgxMatches === void 0 ? void 0 : rgxMatches.length) === 3) {
                            const encryptedError = (0, encoding_1.fromBase64)(rgxMatches[2]);
                            const msgIndex = Number(rgxMatches[1]);
                            const decryptedBase64Error = yield this.encryptionUtils.decrypt(encryptedError, nonces[msgIndex]);
                            const decryptedError = (0, encoding_1.fromUtf8)(decryptedBase64Error);
                            rawLog = rawLog.replace(`encrypted: ${rgxMatches[2]}`, decryptedError);
                            try {
                                jsonLog = JSON.parse(decryptedError);
                            }
                            catch (e) { }
                        }
                    }
                    catch (decryptionError) {
                        // Not encrypted or can't decrypt because not original sender
                    }
                }
                const { TxMsgData } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/base/abci/v1beta1/abci")));
                const txMsgData = TxMsgData.decode((0, encoding_1.fromHex)(tx.data));
                const data = new Array(txMsgData.data.length);
                for (let msgIndex = 0; msgIndex < txMsgData.data.length; msgIndex++) {
                    const nonce = nonces[msgIndex];
                    if (nonce && nonce.length === 32) {
                        try {
                            data[msgIndex] = (0, encoding_1.fromBase64)((0, encoding_1.fromUtf8)(yield this.encryptionUtils.decrypt(txMsgData.data[msgIndex].data, nonce)));
                        }
                        catch (decryptionError) {
                            // Not encrypted or can't decrypt because not original sender
                            data[msgIndex] = txMsgData.data[msgIndex].data;
                        }
                    }
                }
                // Decode input tx
                const decodedTx = (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")))).Tx.decode(tx.tx.value);
                // Decoded input tx messages
                for (let i = 0; i < decodedTx.body.messages.length; i++) {
                    const { typeUrl: msgType, value: msgBytes } = decodedTx.body.messages[i];
                    const msgDecoder = this.msgDecoderRegistry.get(msgType);
                    if (!msgDecoder) {
                        continue;
                    }
                    const msg = {
                        typeUrl: msgType,
                        value: msgDecoder.decode(msgBytes),
                    };
                    // Check if the message needs decryption
                    let contractInputMsgFieldName = "";
                    if (msg.typeUrl === "/secret.compute.v1beta1.MsgInstantiateContract") {
                        contractInputMsgFieldName = "initMsg";
                    }
                    else if (msg.typeUrl === "/secret.compute.v1beta1.MsgExecuteContract") {
                        contractInputMsgFieldName = "msg";
                    }
                    if (contractInputMsgFieldName !== "") {
                        // Encrypted, try to decrypt
                        try {
                            const contractInputMsgBytes = msg.value[contractInputMsgFieldName];
                            const nonce = contractInputMsgBytes.slice(0, 32);
                            const accountPubkey = contractInputMsgBytes.slice(32, 64); // unused in decryption
                            const ciphertext = contractInputMsgBytes.slice(64);
                            const plaintext = yield this.encryptionUtils.decrypt(ciphertext, nonce);
                            msg.value[contractInputMsgFieldName] = JSON.parse((0, encoding_1.fromUtf8)(plaintext).slice(64));
                        }
                        catch (decryptionError) {
                            // Not encrypted or can't decrypt because not original sender
                        }
                    }
                    decodedTx.body.messages[i] = msg;
                }
                return {
                    height: Number(tx.height),
                    transactionHash: tx.txhash,
                    code: tx.code,
                    tx: decodedTx,
                    txBytes: tx.tx.value,
                    rawLog,
                    jsonLog,
                    arrayLog,
                    data,
                    gasUsed: Number(tx.gasUsed),
                    gasWanted: Number(tx.gasWanted),
                };
            })));
        });
    }
    /**
     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
     *
     * If the transaction is included in a block, a {@link Tx} is returned. The caller then
     * usually needs to check for execution success or failure.
     */
    broadcastTx(tx, timeoutMs, checkIntervalMs, mode, waitForCommit, nonces) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            let txhash;
            if (mode === BroadcastMode.Sync) {
                const { BroadcastMode } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/service")));
                const { txResponse } = yield this.txService.broadcastTx({
                    txBytes: tx,
                    mode: BroadcastMode.BROADCAST_MODE_SYNC,
                });
                if (txResponse === null || txResponse === void 0 ? void 0 : txResponse.code) {
                    throw new Error(`Broadcasting transaction failed with code ${txResponse === null || txResponse === void 0 ? void 0 : txResponse.code} (codespace: ${txResponse === null || txResponse === void 0 ? void 0 : txResponse.codespace}). Log: ${txResponse === null || txResponse === void 0 ? void 0 : txResponse.rawLog}`);
                }
                txhash = txResponse.txhash;
            }
            else if (mode === BroadcastMode.Async) {
                const { BroadcastMode } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/service")));
                const { txResponse } = yield this.txService.broadcastTx({
                    txBytes: tx,
                    mode: BroadcastMode.BROADCAST_MODE_ASYNC,
                });
                txhash = txResponse.txhash;
            }
            else {
                throw new Error(`Unknown broadcast mode "${String(mode)}", must be either "${String(BroadcastMode.Sync)}" or "${String(BroadcastMode.Async)}".`);
            }
            if (!waitForCommit) {
                //@ts-ignore
                return { transactionHash: txhash };
            }
            while (true) {
                // sleep first because there's no point in checking right after broadcasting
                yield sleep(checkIntervalMs);
                const result = yield this.getTx(txhash, nonces);
                if (result) {
                    return result;
                }
                if (start + timeoutMs < Date.now()) {
                    throw new Error(`Transaction ID ${txhash} was submitted but was not yet found on the chain. You might want to check later.`);
                }
            }
        });
    }
    prepareAndSign(messages, txOptions) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const gasLimit = (_a = txOptions === null || txOptions === void 0 ? void 0 : txOptions.gasLimit) !== null && _a !== void 0 ? _a : 25000;
            const gasPriceInFeeDenom = (_b = txOptions === null || txOptions === void 0 ? void 0 : txOptions.gasPriceInFeeDenom) !== null && _b !== void 0 ? _b : 0.25;
            const feeDenom = (_c = txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeDenom) !== null && _c !== void 0 ? _c : "uscrt";
            const memo = (_d = txOptions === null || txOptions === void 0 ? void 0 : txOptions.memo) !== null && _d !== void 0 ? _d : "";
            const explicitSignerData = txOptions === null || txOptions === void 0 ? void 0 : txOptions.explicitSignerData;
            const [txRaw, nonces] = yield this.sign(messages, {
                gas: String(gasLimit),
                amount: [
                    {
                        amount: String(gasToFee(gasLimit, gasPriceInFeeDenom)),
                        denom: feeDenom,
                    },
                ],
            }, memo, explicitSignerData);
            const txBytes = (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")))).TxRaw.encode(txRaw).finish();
            return [txBytes, nonces];
        });
    }
    signAndBroadcast(messages, txOptions) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const waitForCommit = (_a = txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForCommit) !== null && _a !== void 0 ? _a : true;
            const broadcastTimeoutMs = (_b = txOptions === null || txOptions === void 0 ? void 0 : txOptions.broadcastTimeoutMs) !== null && _b !== void 0 ? _b : 60000;
            const broadcastCheckIntervalMs = (_c = txOptions === null || txOptions === void 0 ? void 0 : txOptions.broadcastCheckIntervalMs) !== null && _c !== void 0 ? _c : 6000;
            const broadcastMode = (_d = txOptions === null || txOptions === void 0 ? void 0 : txOptions.broadcastMode) !== null && _d !== void 0 ? _d : BroadcastMode.Sync;
            const [txBytes, nonces] = yield this.prepareAndSign(messages, txOptions);
            return this.broadcastTx(txBytes, broadcastTimeoutMs, broadcastCheckIntervalMs, broadcastMode, waitForCommit, nonces);
        });
    }
    simulate(messages, txOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const [txBytes] = yield this.prepareAndSign(messages, txOptions);
            return this.txService.simulate({ txBytes });
        });
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    sign(messages, fee, memo, explicitSignerData) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountFromSigner = (yield this.wallet.getAccounts()).find((account) => account.address === this.address);
            if (!accountFromSigner) {
                throw new Error("Failed to retrieve account from signer");
            }
            let signerData;
            if (explicitSignerData) {
                signerData = explicitSignerData;
            }
            else {
                const account = yield this.query.auth.account({
                    address: this.address,
                });
                if (!account) {
                    throw new Error(`Cannot find account "${this.address}", make sure it has a balance.`);
                }
                if (account.type !== "BaseAccount") {
                    throw new Error(`Cannot sign with account of type "${account.type}", can only sign with "BaseAccount".`);
                }
                const chainId = this.chainId;
                const baseAccount = account.account;
                signerData = {
                    accountNumber: Number(baseAccount.accountNumber),
                    sequence: Number(baseAccount.sequence),
                    chainId: chainId,
                };
            }
            return (0, wallet_amino_1.isOfflineDirectSigner)(this.wallet)
                ? this.signDirect(accountFromSigner, messages, fee, memo, signerData)
                : this.signAmino(accountFromSigner, messages, fee, memo, signerData);
        });
    }
    signAmino(account, messages, fee, memo, { accountNumber, sequence, chainId }) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, wallet_amino_1.isOfflineDirectSigner)(this.wallet)) {
                throw new Error("Wrong signer type! Expected AminoSigner.");
            }
            const signMode = (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/signing/v1beta1/signing")))).SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
            const msgs = yield Promise.all(messages.map((msg) => __awaiter(this, void 0, void 0, function* () {
                yield this.populateCodeHash(msg);
                return msg.toAmino(this.encryptionUtils);
            })));
            const signDoc = makeSignDocAmino(msgs, fee, chainId, memo, accountNumber, sequence);
            const { signature, signed } = yield this.wallet.signAmino(account.address, signDoc);
            const encryptionNonces = {};
            const txBody = {
                typeUrl: "/cosmos.tx.v1beta1.TxBody",
                value: {
                    messages: yield Promise.all(messages.map((msg, index) => __awaiter(this, void 0, void 0, function* () {
                        yield this.populateCodeHash(msg);
                        const asProto = yield msg.toProto(this.encryptionUtils);
                        encryptionNonces[index] = extractNonce(asProto);
                        return asProto;
                    }))),
                    memo: memo,
                },
            };
            const txBodyBytes = yield this.encodeTx(txBody);
            const signedGasLimit = Number(signed.fee.gas);
            const signedSequence = Number(signed.sequence);
            const pubkey = yield encodePubkey((0, wallet_amino_1.encodeSecp256k1Pubkey)(account.pubkey));
            const signedAuthInfoBytes = yield makeAuthInfoBytes([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signMode);
            return [
                (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")))).TxRaw.fromPartial({
                    bodyBytes: txBodyBytes,
                    authInfoBytes: signedAuthInfoBytes,
                    signatures: [(0, encoding_1.fromBase64)(signature.signature)],
                }),
                encryptionNonces,
            ];
        });
    }
    populateCodeHash(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (msg instanceof _1.MsgExecuteContract) {
                if (!msg.codeHash) {
                    msg.codeHash = yield this.query.compute.contractCodeHash(msg.contractAddress);
                }
            }
            else if (msg instanceof _1.MsgInstantiateContract) {
                if (!msg.codeHash) {
                    msg.codeHash = yield this.query.compute.codeHash(Number(msg.codeId));
                }
            }
        });
    }
    encodeTx(txBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const { Any } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/google/protobuf/any")));
            const wrappedMessages = yield Promise.all(txBody.value.messages.map((message) => __awaiter(this, void 0, void 0, function* () {
                const binaryValue = yield message.encode();
                return Any.fromPartial({
                    typeUrl: message.typeUrl,
                    value: binaryValue,
                });
            })));
            const { TxBody } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")));
            const txBodyEncoded = TxBody.fromPartial(Object.assign(Object.assign({}, txBody.value), { messages: wrappedMessages }));
            return TxBody.encode(txBodyEncoded).finish();
        });
    }
    signDirect(account, messages, fee, memo, { accountNumber, sequence, chainId }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, wallet_amino_1.isOfflineDirectSigner)(this.wallet)) {
                throw new Error("Wrong signer type! Expected DirectSigner.");
            }
            const encryptionNonces = {};
            const txBody = {
                typeUrl: "/cosmos.tx.v1beta1.TxBody",
                value: {
                    messages: yield Promise.all(messages.map((msg, index) => __awaiter(this, void 0, void 0, function* () {
                        yield this.populateCodeHash(msg);
                        const asProto = yield msg.toProto(this.encryptionUtils);
                        encryptionNonces[index] = extractNonce(asProto);
                        return asProto;
                    }))),
                    memo: memo,
                },
            };
            const txBodyBytes = yield this.encodeTx(txBody);
            const pubkey = yield encodePubkey((0, wallet_amino_1.encodeSecp256k1Pubkey)(account.pubkey));
            const gasLimit = Number(fee.gas);
            const authInfoBytes = yield makeAuthInfoBytes([{ pubkey, sequence }], fee.amount, gasLimit);
            const signDoc = makeSignDocProto(txBodyBytes, authInfoBytes, chainId, accountNumber);
            const { signature, signed } = yield this.wallet.signDirect(account.address, signDoc);
            return [
                (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")))).TxRaw.fromPartial({
                    bodyBytes: signed.bodyBytes,
                    authInfoBytes: signed.authInfoBytes,
                    signatures: [(0, encoding_1.fromBase64)(signature.signature)],
                }),
                encryptionNonces,
            ];
        });
    }
}
exports.SecretNetworkClient = SecretNetworkClient;
function sleep(ms) {
    return new Promise((accept) => setTimeout(accept, ms));
}
function gasToFee(gasLimit, gasPrice) {
    return Math.ceil(gasLimit * gasPrice);
}
exports.gasToFee = gasToFee;
function extractNonce(msg) {
    if (msg.typeUrl === "/secret.compute.v1beta1.MsgInstantiateContract") {
        return msg.value.initMsg.slice(0, 32);
    }
    if (msg.typeUrl === "/secret.compute.v1beta1.MsgExecuteContract") {
        return msg.value.msg.slice(0, 32);
    }
    return new Uint8Array();
}
/**
 * Creates and serializes an AuthInfo document.
 *
 * This implementation does not support different signing modes for the different signers.
 */
function makeAuthInfoBytes(signers, feeAmount, gasLimit, signMode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!signMode) {
            signMode = (yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/signing/v1beta1/signing")))).SignMode.SIGN_MODE_DIRECT;
        }
        const authInfo = {
            signerInfos: makeSignerInfos(signers, signMode),
            fee: {
                amount: [...feeAmount],
                gasLimit: String(gasLimit),
            },
        };
        const { AuthInfo } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/tx/v1beta1/tx")));
        return AuthInfo.encode(AuthInfo.fromPartial(authInfo)).finish();
    });
}
/**
 * Create signer infos from the provided signers.
 *
 * This implementation does not support different signing modes for the different signers.
 */
function makeSignerInfos(signers, signMode) {
    return signers.map(({ pubkey, sequence, }) => ({
        publicKey: pubkey,
        modeInfo: {
            single: { mode: signMode },
        },
        sequence: String(sequence),
    }));
}
function makeSignDocProto(bodyBytes, authInfoBytes, chainId, accountNumber) {
    return {
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        chainId: chainId,
        accountNumber: String(accountNumber),
    };
}
function encodePubkey(pubkey) {
    return __awaiter(this, void 0, void 0, function* () {
        const { Any } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/google/protobuf/any")));
        if (isSecp256k1Pubkey(pubkey)) {
            const { PubKey } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/crypto/secp256k1/keys")));
            const pubkeyProto = PubKey.fromPartial({
                key: (0, encoding_1.fromBase64)(pubkey.value),
            });
            return Any.fromPartial({
                typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                value: Uint8Array.from(PubKey.encode(pubkeyProto).finish()),
            });
        }
        else if (isMultisigThresholdPubkey(pubkey)) {
            const { LegacyAminoPubKey } = yield Promise.resolve().then(() => __importStar(require("./protobuf_stuff/cosmos/crypto/multisig/keys")));
            const pubkeyProto = LegacyAminoPubKey.fromPartial({
                threshold: Number(pubkey.value.threshold),
                publicKeys: pubkey.value.pubkeys.map(encodePubkey),
            });
            return Any.fromPartial({
                typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
                value: Uint8Array.from(LegacyAminoPubKey.encode(pubkeyProto).finish()),
            });
        }
        else {
            throw new Error(`Pubkey type ${pubkey.type} not recognized`);
        }
    });
}
function isSecp256k1Pubkey(pubkey) {
    return pubkey.type === "tendermint/PubKeySecp256k1";
}
function isMultisigThresholdPubkey(pubkey) {
    return pubkey.type === "tendermint/PubKeyMultisigThreshold";
}
function makeSignDocAmino(msgs, fee, chainId, memo, accountNumber, sequence) {
    return {
        chain_id: chainId,
        account_number: String(accountNumber),
        sequence: String(sequence),
        fee: fee,
        msgs: msgs,
        memo: memo || "",
    };
}
var TxResultCode;
(function (TxResultCode) {
    /** Success is returned if the transaction executed successfuly */
    TxResultCode[TxResultCode["Success"] = 0] = "Success";
    /** ErrInternal should never be exposed, but we reserve this code for non-specified errors */
    TxResultCode[TxResultCode["ErrInternal"] = 1] = "ErrInternal";
    /** ErrTxDecode is returned if we cannot parse a transaction */
    TxResultCode[TxResultCode["ErrTxDecode"] = 2] = "ErrTxDecode";
    /** ErrInvalidSequence is used the sequence number (nonce) is incorrect for the signature */
    TxResultCode[TxResultCode["ErrInvalidSequence"] = 3] = "ErrInvalidSequence";
    /** ErrUnauthorized is used whenever a request without sufficient authorization is handled. */
    TxResultCode[TxResultCode["ErrUnauthorized"] = 4] = "ErrUnauthorized";
    /** ErrInsufficientFunds is used when the account cannot pay requested amount. */
    TxResultCode[TxResultCode["ErrInsufficientFunds"] = 5] = "ErrInsufficientFunds";
    /** ErrUnknownRequest to doc */
    TxResultCode[TxResultCode["ErrUnknownRequest"] = 6] = "ErrUnknownRequest";
    /** ErrInvalidAddress to doc */
    TxResultCode[TxResultCode["ErrInvalidAddress"] = 7] = "ErrInvalidAddress";
    /** ErrInvalidPubKey to doc */
    TxResultCode[TxResultCode["ErrInvalidPubKey"] = 8] = "ErrInvalidPubKey";
    /** ErrUnknownAddress to doc */
    TxResultCode[TxResultCode["ErrUnknownAddress"] = 9] = "ErrUnknownAddress";
    /** ErrInvalidCoins to doc */
    TxResultCode[TxResultCode["ErrInvalidCoins"] = 10] = "ErrInvalidCoins";
    /** ErrOutOfGas to doc */
    TxResultCode[TxResultCode["ErrOutOfGas"] = 11] = "ErrOutOfGas";
    /** ErrMemoTooLarge to doc */
    TxResultCode[TxResultCode["ErrMemoTooLarge"] = 12] = "ErrMemoTooLarge";
    /** ErrInsufficientFee to doc */
    TxResultCode[TxResultCode["ErrInsufficientFee"] = 13] = "ErrInsufficientFee";
    /** ErrTooManySignatures to doc */
    TxResultCode[TxResultCode["ErrTooManySignatures"] = 14] = "ErrTooManySignatures";
    /** ErrNoSignatures to doc */
    TxResultCode[TxResultCode["ErrNoSignatures"] = 15] = "ErrNoSignatures";
    /** ErrJSONMarshal defines an ABCI typed JSON marshalling error */
    TxResultCode[TxResultCode["ErrJSONMarshal"] = 16] = "ErrJSONMarshal";
    /** ErrJSONUnmarshal defines an ABCI typed JSON unmarshalling error */
    TxResultCode[TxResultCode["ErrJSONUnmarshal"] = 17] = "ErrJSONUnmarshal";
    /** ErrInvalidRequest defines an ABCI typed error where the request contains invalid data. */
    TxResultCode[TxResultCode["ErrInvalidRequest"] = 18] = "ErrInvalidRequest";
    /** ErrTxInMempoolCache defines an ABCI typed error where a tx already exists in the mempool. */
    TxResultCode[TxResultCode["ErrTxInMempoolCache"] = 19] = "ErrTxInMempoolCache";
    /** ErrMempoolIsFull defines an ABCI typed error where the mempool is full. */
    TxResultCode[TxResultCode["ErrMempoolIsFull"] = 20] = "ErrMempoolIsFull";
    /** ErrTxTooLarge defines an ABCI typed error where tx is too large. */
    TxResultCode[TxResultCode["ErrTxTooLarge"] = 21] = "ErrTxTooLarge";
    /** ErrKeyNotFound defines an error when the key doesn't exist */
    TxResultCode[TxResultCode["ErrKeyNotFound"] = 22] = "ErrKeyNotFound";
    /** ErrWrongPassword defines an error when the key password is invalid. */
    TxResultCode[TxResultCode["ErrWrongPassword"] = 23] = "ErrWrongPassword";
    /** ErrorInvalidSigner defines an error when the tx intended signer does not match the given signer. */
    TxResultCode[TxResultCode["ErrorInvalidSigner"] = 24] = "ErrorInvalidSigner";
    /** ErrorInvalidGasAdjustment defines an error for an invalid gas adjustment */
    TxResultCode[TxResultCode["ErrorInvalidGasAdjustment"] = 25] = "ErrorInvalidGasAdjustment";
    /** ErrInvalidHeight defines an error for an invalid height */
    TxResultCode[TxResultCode["ErrInvalidHeight"] = 26] = "ErrInvalidHeight";
    /** ErrInvalidVersion defines a general error for an invalid version */
    TxResultCode[TxResultCode["ErrInvalidVersion"] = 27] = "ErrInvalidVersion";
    /** ErrInvalidChainID defines an error when the chain-id is invalid. */
    TxResultCode[TxResultCode["ErrInvalidChainID"] = 28] = "ErrInvalidChainID";
    /** ErrInvalidType defines an error an invalid type. */
    TxResultCode[TxResultCode["ErrInvalidType"] = 29] = "ErrInvalidType";
    /** ErrTxTimeoutHeight defines an error for when a tx is rejected out due to an explicitly set timeout height. */
    TxResultCode[TxResultCode["ErrTxTimeoutHeight"] = 30] = "ErrTxTimeoutHeight";
    /** ErrUnknownExtensionOptions defines an error for unknown extension options. */
    TxResultCode[TxResultCode["ErrUnknownExtensionOptions"] = 31] = "ErrUnknownExtensionOptions";
    /** ErrWrongSequence defines an error where the account sequence defined in the signer info doesn't match the account's actual sequence number. */
    TxResultCode[TxResultCode["ErrWrongSequence"] = 32] = "ErrWrongSequence";
    /** ErrPackAny defines an error when packing a protobuf message to Any fails. */
    TxResultCode[TxResultCode["ErrPackAny"] = 33] = "ErrPackAny";
    /** ErrUnpackAny defines an error when unpacking a protobuf message from Any fails. */
    TxResultCode[TxResultCode["ErrUnpackAny"] = 34] = "ErrUnpackAny";
    /** ErrLogic defines an internal logic error, e.g. an invariant or assertion that is violated. It is a programmer error, not a user-facing error. */
    TxResultCode[TxResultCode["ErrLogic"] = 35] = "ErrLogic";
    /** ErrConflict defines a conflict error, e.g. when two goroutines try to access the same resource and one of them fails. */
    TxResultCode[TxResultCode["ErrConflict"] = 36] = "ErrConflict";
    /** ErrNotSupported is returned when we call a branch of a code which is currently not supported. */
    TxResultCode[TxResultCode["ErrNotSupported"] = 37] = "ErrNotSupported";
    /** ErrNotFound defines an error when requested entity doesn't exist in the state. */
    TxResultCode[TxResultCode["ErrNotFound"] = 38] = "ErrNotFound";
    /** ErrIO should be used to wrap internal errors caused by external operation. Examples: not DB domain error, file writing etc... */
    TxResultCode[TxResultCode["ErrIO"] = 39] = "ErrIO";
    /** ErrAppConfig defines an error occurred if min-gas-prices field in BaseConfig is empty. */
    TxResultCode[TxResultCode["ErrAppConfig"] = 40] = "ErrAppConfig";
    /** ErrPanic is only set when we recover from a panic, so we know to redact potentially sensitive system info. */
    TxResultCode[TxResultCode["ErrPanic"] = 111222] = "ErrPanic";
})(TxResultCode = exports.TxResultCode || (exports.TxResultCode = {}));
//# sourceMappingURL=secret_network_client.js.map