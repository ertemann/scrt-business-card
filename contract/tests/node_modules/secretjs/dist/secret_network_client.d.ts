import { MsgBeginRedelegateParams, MsgCreateValidatorParams, MsgDelegateParams, MsgDepositParams, MsgEditValidatorParams, MsgExecParams, MsgExecuteContractParams, MsgFundCommunityPoolParams, MsgGrantAllowanceParams, MsgGrantParams, MsgInstantiateContractParams, MsgMultiSendParams, MsgRevokeAllowanceParams, MsgRevokeParams, MsgSendParams, MsgSetWithdrawAddressParams, MsgStoreCodeParams, MsgSubmitEvidenceParams, MsgSubmitProposalParams, MsgTransferParams, MsgUndelegateParams, MsgUnjailParams, MsgVerifyInvariantParams, MsgVoteParams, MsgVoteWeightedParams, MsgWithdrawDelegatorRewardParams, MsgWithdrawValidatorCommissionParams } from ".";
import { EncryptionUtils } from "./encryption";
import { PermitSigner } from "./extensions/access_control/permit/permit_signer";
import { CreateViewingKeyContractParams, SetViewingKeyContractParams } from "./extensions/access_control/viewing_key/params";
import { Snip20Querier } from "./extensions/snip20";
import { Snip20DecreaseAllowanceOptions, Snip20IncreaseAllowanceOptions, Snip20SendOptions, Snip20TransferOptions } from "./extensions/snip20/types";
import { Snip721Querier } from "./extensions/snip721";
import { Snip721AddMinterOptions, Snip721MintOptions, Snip721SendOptions } from "./extensions/snip721/types";
import { AuthQuerier, ComputeQuerier } from "./query";
import { Msg } from "./tx";
import { AccountData, AminoSigner, AminoSignResponse, Signer, StdSignDoc } from "./wallet_amino";
export declare type CreateClientOptions = {
    /** A gRPC-web url, by default on port 9091 */
    grpcWebUrl: string;
    /** The chain-id is used in encryption code & when signing txs. */
    chainId: string;
    /** A wallet for signing transactions & permits. When `wallet` is supplied, `walletAddress` & `chainId` must be supplied too. */
    wallet?: Signer;
    /** walletAddress is the spesific account address in the wallet that is permitted to sign transactions & permits. */
    walletAddress?: string;
    /** Passing `encryptionSeed` will allow tx decryption at a later time. Ignored if `encryptionUtils` is supplied. */
    encryptionSeed?: Uint8Array;
    /** `encryptionUtils` overrides the default {@link EncryptionUtilsImpl}. */
    encryptionUtils?: EncryptionUtils;
};
/**
 * SingleMsgTx is a function that broadcasts a single message transaction.
 * It also has a `simulate()` method to execute the transaction without
 * committing it on-chain. This is helpful for gas estimation.
 */
export declare type SingleMsgTx<T> = {
    (params: T, txOptions?: TxOptions): Promise<Tx>;
    simulate(params: T, txOptions?: TxOptions): Promise<import("./protobuf_stuff/cosmos/tx/v1beta1/service").SimulateResponse>;
};
export declare enum BroadcastMode {
    /**
     * Broadcast transaction to mempool and wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */
    Sync = "Sync",
    /**
     * Broadcast transaction to mempool and do not wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */
    Async = "Async"
}
export declare type TxOptions = {
    /** Defaults to `25_000`. */
    gasLimit?: number;
    /** E.g. gasPriceInFeeDenom=0.25 & feeDenom="uscrt" => Total fee for tx is `0.25 * gasLimit`uscrt. Defaults to `0.25`. */
    gasPriceInFeeDenom?: number;
    /** Defaults to `"uscrt"`. */
    feeDenom?: string;
    /** Defaults to `""`. */
    memo?: string;
    /** If `false` returns immediately with only the `transactionHash` field set. Defaults to `true`. */
    waitForCommit?: boolean;
    /**
     * How much time (in milliseconds) to wait for tx to commit on-chain.
     *
     * Defaults to `60_000`. Ignored if `waitForCommit = false`.
     */
    broadcastTimeoutMs?: number;
    /**
     * When waiting for the tx to commit on-chain, how much time (in milliseconds) to wait between checks.
     *
     * Smaller intervals will cause more load on your node provider. Keep in mind that blocks on Secret Network take about 6 seconds to finilize.
     *
     * Defaults to `6_000`. Ignored if `waitForCommit = false`.
     */
    broadcastCheckIntervalMs?: number;
    /**
     * If `BroadcastMode.Sync` - Broadcast transaction to mempool and wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     *
     * If `BroadcastMode.Async` Broadcast transaction to mempool and do not wait for CheckTx response.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */
    broadcastMode?: BroadcastMode;
    /**
     * explicitSignerData can be used to override `chainId`, `accountNumber` & `accountSequence`.
     * This is usefull when using {@link BroadcastMode.Async} or when you don't want secretjs
     * to query for `accountNumber` & `accountSequence` from the chain. (smoother in UIs, less load on your node provider).
     */
    explicitSignerData?: SignerData;
};
/**
 * Signing information for a single signer that is not included in the transaction.
 *
 * @see https://github.com/cosmos/cosmos-sdk/blob/v0.42.2/x/auth/signing/sign_mode_handler.go#L23-L37
 */
export interface SignerData {
    readonly accountNumber: number;
    readonly sequence: number;
    readonly chainId: string;
}
export declare class ReadonlySigner implements AminoSigner {
    getAccounts(): Promise<readonly AccountData[]>;
    signAmino(_signerAddress: string, _signDoc: StdSignDoc): Promise<AminoSignResponse>;
}
export declare type Querier = {
    /** Returns a transaction with a txhash. Must be 64 character upper-case hex string */
    getTx: (hash: string) => Promise<Tx | null>;
    /**
     * To tell which events you want, you need to provide a query. query is a string, which has a form: "condition AND condition ..." (no OR at the moment).
     *
     * condition has a form: "key operation operand". key is a string with a restricted set of possible symbols (\t\n\r\()"'=>< are not allowed).
     *
     * operation can be "=", "<", "<=", ">", ">=", "CONTAINS" AND "EXISTS". operand can be a string (escaped with single quotes), number, date or time.
     *
     * Examples:
     * - `tx.hash = 'XYZ'` # single transaction
     * - `tx.height = 5` # all txs of the fifth block
     * - `create_validator.validator = 'ABC'` # tx where validator ABC was created
     *
     * Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height. You can provide additional event keys that were emitted during the transaction.
     *
     * All events are indexed by a composite key of the form `{eventType}.{evenAttrKey}`.
     *
     * Multiple event types with duplicate keys are allowed and are meant to categorize unique and distinct events.
     *
     * To create a query for txs where AddrA transferred funds: `transfer.sender = 'AddrA'`.
     *
     */
    txsQuery: (query: string) => Promise<Tx[]>;
    auth: AuthQuerier;
    authz: import("./protobuf_stuff/cosmos/authz/v1beta1/query").Query;
    bank: import("./protobuf_stuff/cosmos/bank/v1beta1/query").Query;
    compute: ComputeQuerier;
    distribution: import("./protobuf_stuff/cosmos/distribution/v1beta1/query").Query;
    evidence: import("./protobuf_stuff/cosmos/evidence/v1beta1/query").Query;
    feegrant: import("./protobuf_stuff/cosmos/feegrant/v1beta1/query").Query;
    gov: import("./protobuf_stuff/cosmos/gov/v1beta1/query").Query;
    ibc_channel: import("./protobuf_stuff/ibc/core/channel/v1/query").Query;
    ibc_client: import("./protobuf_stuff/ibc/core/client/v1/query").Query;
    ibc_connection: import("./protobuf_stuff/ibc/core/connection/v1/query").Query;
    ibc_transfer: import("./protobuf_stuff/ibc/applications/transfer/v1/query").Query;
    mint: import("./protobuf_stuff/cosmos/mint/v1beta1/query").Query;
    params: import("./protobuf_stuff/cosmos/params/v1beta1/query").Query;
    registration: import("./protobuf_stuff/secret/registration/v1beta1/query").Query;
    slashing: import("./protobuf_stuff/cosmos/slashing/v1beta1/query").Query;
    staking: import("./protobuf_stuff/cosmos/staking/v1beta1/query").Query;
    tendermint: import("./protobuf_stuff/cosmos/base/tendermint/v1beta1/query").Service;
    upgrade: import("./protobuf_stuff/cosmos/upgrade/v1beta1/query").Query;
    snip20: Snip20Querier;
    snip721: Snip721Querier;
};
export declare type ArrayLog = Array<{
    msg: number;
    type: string;
    key: string;
    value: string;
}>;
export declare type JsonLog = Array<{
    msg_index: number;
    events: Array<{
        type: string;
        attributes: Array<{
            key: string;
            value: string;
        }>;
    }>;
}>;
/**
 * MsgData defines the data returned in a Result object during message
 * execution.
 */
export declare type MsgData = {
    msgType: string;
    data: Uint8Array;
};
/** TxBody is the body of a transaction that all signers sign over. */
export interface TxBody {
    /**
     * messages is a list of messages to be executed. The required signers of
     * those messages define the number and order of elements in AuthInfo's
     * signer_infos and Tx's signatures. Each required signer address is added to
     * the list only the first time it occurs.
     * By convention, the first required signer (usually from the first message)
     * is referred to as the primary signer and pays the fee for the whole
     * transaction.
     */
    messages: Array<{
        typeUrl: string;
        value: any;
    }>;
    /**
     * memo is any arbitrary note/comment to be added to the transaction.
     * WARNING: in clients, any publicly exposed text should not be called memo,
     * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
     */
    memo: string;
    /**
     * timeout is the block height after which this transaction will not
     * be processed by the chain
     */
    timeoutHeight: string;
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, the transaction will be rejected
     */
    extensionOptions: import("./protobuf_stuff/google/protobuf/any").Any[];
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, they will be ignored
     */
    nonCriticalExtensionOptions: import("./protobuf_stuff/google/protobuf/any").Any[];
}
export declare type TxContent = {
    /** body is the processable content of the transaction */
    body: TxBody;
    /**
     * auth_info is the authorization related content of the transaction,
     * specifically signers, signer modes and fee
     */
    authInfo: import("./protobuf_stuff/cosmos/tx/v1beta1/tx").AuthInfo;
    /**
     * signatures is a list of signatures that matches the length and order of
     * AuthInfo's signer_infos to allow connecting signature meta information like
     * public key and signing mode by position.
     */
    signatures: Uint8Array[];
};
/** A transaction that is indexed as part of the transaction history */
export declare type Tx = {
    readonly height: number;
    /** Transaction hash (might be used as transaction ID). Guaranteed to be non-empty upper-case hex */
    readonly transactionHash: string;
    /** Transaction execution error code. 0 on success. See {@link TxResultCode}. */
    readonly code: TxResultCode;
    /**
     * If code != 0, rawLog contains the error.
     *
     * If code = 0 you'll probably want to use `jsonLog` or `arrayLog`. Values are not decrypted.
     */
    readonly rawLog: string;
    /** If code = 0, `jsonLog = JSON.parse(rawLow)`. Values are decrypted if possible. */
    readonly jsonLog?: JsonLog;
    /** If code = 0, `arrayLog` is a flattened `jsonLog`. Values are decrypted if possible. */
    readonly arrayLog?: ArrayLog;
    /** Return value (if there's any) for each input message */
    readonly data: Array<Uint8Array>;
    /**
     * Decoded transaction input.
     */
    readonly tx: TxContent;
    /**
     * Raw transaction bytes stored in Tendermint.
     *
     * If you hash this, you get the transaction hash (= transaction ID):
     *
     * ```js
     * import { sha256 } from "@noble/hashes/sha256";
     * import { toHex } from "@cosmjs/encoding";
     *
     * const transactionHash = toHex(sha256(indexTx.tx)).toUpperCase();
     * ```
     */
    readonly txBytes: Uint8Array;
    readonly gasUsed: number;
    readonly gasWanted: number;
};
export declare type TxSender = {
    /**
     * Sign and broadcast a transaction to Secret Network.
     *
     * @param {TxOptions} [options] Options for signing and broadcasting
     * @param {Number} [options.gasLimit=25_000]
     * @param {Number} [options.gasPriceInFeeDenom=0.25] E.g. gasPriceInFeeDenom=0.25 & feeDenom="uscrt" => Total fee for tx is `0.25 * gasLimit`uscrt.
     * @param {String} [options.feeDenom="uscrt"]
     * @param {String} [options.memo=""]
     * @param {boolean} [options.waitForCommit=true] If false returns immediately with `transactionHash`. Defaults to `true`.
     * @param {Number} [options.broadcastTimeoutMs=60_000] How much time (in milliseconds) to wait for tx to commit on-chain. Ignored if `waitForCommit = false`.
     * @param {Number} [options.broadcastCheckIntervalMs=6_000] When waiting for the tx to commit on-chain, how much time (in milliseconds) to wait between checks. Smaller intervals will cause more load on your node provider. Keep in mind that blocks on Secret Network take about 6 seconds to finilize. Ignored if `waitForCommit = false`.
     * @param {BroadcastMode} [options.broadcastMode=BroadcastMode.Sync] If {@link BroadcastMode.Sync} - Broadcast transaction to mempool and wait for CheckTx response. @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync. If {@link BroadcastMode.Async} Broadcast transaction to mempool and do not wait for CheckTx response. @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async.
     * @param {SignerData} [options.explicitSignerData] explicitSignerData  can be used to override `chainId`, `accountNumber` & `accountSequence`. This is usefull when using {@link BroadcastMode.Async} or when you don't want secretjs to query for `accountNumber` & `accountSequence` from the chain. (smoother in UIs, less load on your node provider).
     * @param {Number} [options.explicitSignerData.accountNumber]
     * @param {Number} [options.explicitSignerData.sequence]
     * @param {String} [options.explicitSignerData.chainId]
     * @param {Msg[]} messages A list of messages, executed sequentially. If all messages succeeds then the transaction succeed, and the resulting {@link Tx} object will have `code = 0`. If at lease one message fails, the entire transaction is reverted and {@link Tx} `code` field will not be `0`.
     *
     * List of possible Msgs:
     *   - authz           {@link MsgExec}
     *   - authz           {@link MsgGrant}
     *   - authz           {@link MsgRevoke}
     *   - bank            {@link MsgMultiSend}
     *   - bank            {@link MsgSend}
     *   - compute         {@link MsgExecuteContract}
     *   - compute         {@link MsgInstantiateContract}
     *   - compute         {@link MsgStoreCode}
     *   - crisis          {@link MsgVerifyInvariant}
     *   - distribution    {@link MsgFundCommunityPool}
     *   - distribution    {@link MsgSetWithdrawAddress}
     *   - distribution    {@link MsgWithdrawDelegatorReward}
     *   - distribution    {@link MsgWithdrawValidatorCommission}
     *   - evidence        {@link MsgSubmitEvidence}
     *   - feegrant        {@link MsgGrantAllowance}
     *   - feegrant        {@link MsgRevokeAllowance}
     *   - gov             {@link MsgDeposit}
     *   - gov             {@link MsgSubmitProposal}
     *   - gov             {@link MsgVote}
     *   - gov             {@link MsgVoteWeighted}
     *   - ibc_channel     {@link MsgAcknowledgement}
     *   - ibc_channel     {@link MsgChannelCloseConfirm}
     *   - ibc_channel     {@link MsgChannelCloseInit}
     *   - ibc_channel     {@link MsgChannelOpenAck}
     *   - ibc_channel     {@link MsgChannelOpenConfirm}
     *   - ibc_channel     {@link MsgChannelOpenInit}
     *   - ibc_channel     {@link MsgChannelOpenTry}
     *   - ibc_channel     {@link MsgRecvPacket}
     *   - ibc_channel     {@link MsgTimeout}
     *   - ibc_channel     {@link MsgTimeoutOnClose}
     *   - ibc_client      {@link MsgCreateClient}
     *   - ibc_client      {@link MsgSubmitMisbehaviour}
     *   - ibc_client      {@link MsgUpdateClient}
     *   - ibc_client      {@link MsgUpgradeClient}
     *   - ibc_connection  {@link MsgConnectionOpenAck}
     *   - ibc_connection  {@link MsgConnectionOpenConfirm}
     *   - ibc_connection  {@link MsgConnectionOpenInit}
     *   - ibc_connection  {@link MsgConnectionOpenTry}
     *   - ibc_transfer    {@link MsgTransfer}
     *   - slashing        {@link MsgUnjail}
     *   - staking         {@link MsgBeginRedelegate}
     *   - staking         {@link MsgCreateValidator}
     *   - staking         {@link MsgDelegate}
     *   - staking         {@link MsgEditValidator}
     *   - staking         {@link MsgUndelegate}
     */
    broadcast: (messages: Msg[], txOptions?: TxOptions) => Promise<Tx>;
    /**
     * Simulates a transaction on the node without broadcasting it to the chain.
     * Can be used to get a gas estimation or to see the output without actually committing a transaction on-chain.
     * The input should be exactly how you'd use it in `broadcast`.
     */
    simulate: (messages: Msg[], txOptions?: TxOptions) => Promise<import("./protobuf_stuff/cosmos/tx/v1beta1/service").SimulateResponse>;
    snip721: {
        send: SingleMsgTx<MsgExecuteContractParams<Snip721SendOptions>>;
        mint: SingleMsgTx<MsgExecuteContractParams<Snip721MintOptions>>;
        addMinter: SingleMsgTx<MsgExecuteContractParams<Snip721AddMinterOptions>>;
        setViewingKey: SingleMsgTx<SetViewingKeyContractParams>;
        createViewingKey: SingleMsgTx<CreateViewingKeyContractParams>;
    };
    snip20: {
        send: SingleMsgTx<MsgExecuteContractParams<Snip20SendOptions>>;
        transfer: SingleMsgTx<MsgExecuteContractParams<Snip20TransferOptions>>;
        increaseAllowance: SingleMsgTx<MsgExecuteContractParams<Snip20IncreaseAllowanceOptions>>;
        decreaseAllowance: SingleMsgTx<MsgExecuteContractParams<Snip20DecreaseAllowanceOptions>>;
        setViewingKey: SingleMsgTx<SetViewingKeyContractParams>;
        createViewingKey: SingleMsgTx<CreateViewingKeyContractParams>;
    };
    authz: {
        /**
         * MsgExec attempts to execute the provided messages using
         * authorizations granted to the grantee. Each message should have only
         * one signer corresponding to the granter of the authorization.
         */
        exec: SingleMsgTx<MsgExecParams>;
        /**
         * MsgGrant is a request type for Grant method. It declares authorization to the grantee
         * on behalf of the granter with the provided expiration time.
         */
        grant: SingleMsgTx<MsgGrantParams>;
        /**
         * MsgRevoke revokes any authorization with the provided sdk.Msg type on the
         * granter's account with that has been granted to the grantee.
         */
        revoke: SingleMsgTx<MsgRevokeParams>;
    };
    bank: {
        /** MsgMultiSend represents an arbitrary multi-in, multi-out send message. */
        multiSend: SingleMsgTx<MsgMultiSendParams>;
        /** MsgSend represents a message to send coins from one account to another. */
        send: SingleMsgTx<MsgSendParams>;
    };
    compute: {
        /** Execute a function on a contract */
        executeContract: SingleMsgTx<MsgExecuteContractParams<object>>;
        /** Instantiate a contract from code id */
        instantiateContract: SingleMsgTx<MsgInstantiateContractParams>;
        /** Upload a compiled contract to Secret Network */
        storeCode: SingleMsgTx<MsgStoreCodeParams>;
    };
    crisis: {
        /** MsgVerifyInvariant represents a message to verify a particular invariance. */
        verifyInvariant: SingleMsgTx<MsgVerifyInvariantParams>;
    };
    distribution: {
        /**
         * MsgFundCommunityPool allows an account to directly
         * fund the community pool.
         */
        fundCommunityPool: SingleMsgTx<MsgFundCommunityPoolParams>;
        /**
         * MsgSetWithdrawAddress sets the withdraw address for
         * a delegator (or validator self-delegation).
         */
        setWithdrawAddress: SingleMsgTx<MsgSetWithdrawAddressParams>;
        /**
         * MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator
         * from a single validator.
         */
        withdrawDelegatorReward: SingleMsgTx<MsgWithdrawDelegatorRewardParams>;
        /**
         * MsgWithdrawValidatorCommission withdraws the full commission to the validator
         * address.
         */
        withdrawValidatorCommission: SingleMsgTx<MsgWithdrawValidatorCommissionParams>;
    };
    evidence: {
        /**
         * MsgSubmitEvidence represents a message that supports submitting arbitrary
         * Evidence of misbehavior such as equivocation or counterfactual signing.
         */
        submitEvidence: SingleMsgTx<MsgSubmitEvidenceParams>;
    };
    feegrant: {
        /**
         * MsgGrantAllowance adds permission for Grantee to spend up to Allowance
         * of fees from the account of Granter.
         */
        grantAllowance: SingleMsgTx<MsgGrantAllowanceParams>;
        /** MsgRevokeAllowance removes any existing Allowance from Granter to Grantee. */
        revokeAllowance: SingleMsgTx<MsgRevokeAllowanceParams>;
    };
    gov: {
        /** MsgDeposit defines a message to submit a deposit to an existing proposal. */
        deposit: SingleMsgTx<MsgDepositParams>;
        /**
         * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary
         * proposal Content.
         */
        submitProposal: SingleMsgTx<MsgSubmitProposalParams>;
        /** MsgVote defines a message to cast a vote. */
        vote: SingleMsgTx<MsgVoteParams>;
        /** MsgVoteWeighted defines a message to cast a vote, with an option to split the vote. */
        voteWeighted: SingleMsgTx<MsgVoteWeightedParams>;
    };
    ibc: {
        /**
         * MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between
         * ICS20 enabled chains. See ICS Spec here:
         * https://github.com/cosmos/ics/tree/master/spec/ics-020-fungible-token-transfer#data-structures
         */
        transfer: SingleMsgTx<MsgTransferParams>;
    };
    slashing: {
        /** MsgUnjail defines a message to release a validator from jail. */
        unjail: SingleMsgTx<MsgUnjailParams>;
    };
    staking: {
        /** MsgBeginRedelegate defines an SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator. */
        beginRedelegate: SingleMsgTx<MsgBeginRedelegateParams>;
        /** MsgCreateValidator defines an SDK message for creating a new validator. */
        createValidator: SingleMsgTx<MsgCreateValidatorParams>;
        /** MsgDelegate defines an SDK message for performing a delegation of coins from a delegator to a validator. */
        delegate: SingleMsgTx<MsgDelegateParams>;
        /** MsgEditValidator defines an SDK message for editing an existing validator. */
        editValidator: SingleMsgTx<MsgEditValidatorParams>;
        /** MsgUndelegate defines an SDK message for performing an undelegation from a delegate and a validator */
        undelegate: SingleMsgTx<MsgUndelegateParams>;
    };
};
export declare class SecretNetworkClient {
    readonly query: Querier;
    readonly tx: TxSender;
    readonly address: string;
    private readonly txService;
    private readonly wallet;
    private readonly chainId;
    private readonly msgDecoderRegistry;
    private encryptionUtils;
    utils: {
        accessControl: {
            permit: PermitSigner;
        };
    };
    /** Creates a new SecretNetworkClient client. For a readonly client pass just the `grpcUrl` param. */
    static create(options: CreateClientOptions): Promise<SecretNetworkClient>;
    private constructor();
    private getTx;
    private txsQuery;
    /**
     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
     *
     * If the transaction is included in a block, a {@link Tx} is returned. The caller then
     * usually needs to check for execution success or failure.
     */
    private broadcastTx;
    private prepareAndSign;
    private signAndBroadcast;
    private simulate;
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    private sign;
    private signAmino;
    private populateCodeHash;
    private encodeTx;
    private signDirect;
}
export declare function gasToFee(gasLimit: number, gasPrice: number): number;
export declare enum TxResultCode {
    /** Success is returned if the transaction executed successfuly */
    Success = 0,
    /** ErrInternal should never be exposed, but we reserve this code for non-specified errors */
    ErrInternal = 1,
    /** ErrTxDecode is returned if we cannot parse a transaction */
    ErrTxDecode = 2,
    /** ErrInvalidSequence is used the sequence number (nonce) is incorrect for the signature */
    ErrInvalidSequence = 3,
    /** ErrUnauthorized is used whenever a request without sufficient authorization is handled. */
    ErrUnauthorized = 4,
    /** ErrInsufficientFunds is used when the account cannot pay requested amount. */
    ErrInsufficientFunds = 5,
    /** ErrUnknownRequest to doc */
    ErrUnknownRequest = 6,
    /** ErrInvalidAddress to doc */
    ErrInvalidAddress = 7,
    /** ErrInvalidPubKey to doc */
    ErrInvalidPubKey = 8,
    /** ErrUnknownAddress to doc */
    ErrUnknownAddress = 9,
    /** ErrInvalidCoins to doc */
    ErrInvalidCoins = 10,
    /** ErrOutOfGas to doc */
    ErrOutOfGas = 11,
    /** ErrMemoTooLarge to doc */
    ErrMemoTooLarge = 12,
    /** ErrInsufficientFee to doc */
    ErrInsufficientFee = 13,
    /** ErrTooManySignatures to doc */
    ErrTooManySignatures = 14,
    /** ErrNoSignatures to doc */
    ErrNoSignatures = 15,
    /** ErrJSONMarshal defines an ABCI typed JSON marshalling error */
    ErrJSONMarshal = 16,
    /** ErrJSONUnmarshal defines an ABCI typed JSON unmarshalling error */
    ErrJSONUnmarshal = 17,
    /** ErrInvalidRequest defines an ABCI typed error where the request contains invalid data. */
    ErrInvalidRequest = 18,
    /** ErrTxInMempoolCache defines an ABCI typed error where a tx already exists in the mempool. */
    ErrTxInMempoolCache = 19,
    /** ErrMempoolIsFull defines an ABCI typed error where the mempool is full. */
    ErrMempoolIsFull = 20,
    /** ErrTxTooLarge defines an ABCI typed error where tx is too large. */
    ErrTxTooLarge = 21,
    /** ErrKeyNotFound defines an error when the key doesn't exist */
    ErrKeyNotFound = 22,
    /** ErrWrongPassword defines an error when the key password is invalid. */
    ErrWrongPassword = 23,
    /** ErrorInvalidSigner defines an error when the tx intended signer does not match the given signer. */
    ErrorInvalidSigner = 24,
    /** ErrorInvalidGasAdjustment defines an error for an invalid gas adjustment */
    ErrorInvalidGasAdjustment = 25,
    /** ErrInvalidHeight defines an error for an invalid height */
    ErrInvalidHeight = 26,
    /** ErrInvalidVersion defines a general error for an invalid version */
    ErrInvalidVersion = 27,
    /** ErrInvalidChainID defines an error when the chain-id is invalid. */
    ErrInvalidChainID = 28,
    /** ErrInvalidType defines an error an invalid type. */
    ErrInvalidType = 29,
    /** ErrTxTimeoutHeight defines an error for when a tx is rejected out due to an explicitly set timeout height. */
    ErrTxTimeoutHeight = 30,
    /** ErrUnknownExtensionOptions defines an error for unknown extension options. */
    ErrUnknownExtensionOptions = 31,
    /** ErrWrongSequence defines an error where the account sequence defined in the signer info doesn't match the account's actual sequence number. */
    ErrWrongSequence = 32,
    /** ErrPackAny defines an error when packing a protobuf message to Any fails. */
    ErrPackAny = 33,
    /** ErrUnpackAny defines an error when unpacking a protobuf message from Any fails. */
    ErrUnpackAny = 34,
    /** ErrLogic defines an internal logic error, e.g. an invariant or assertion that is violated. It is a programmer error, not a user-facing error. */
    ErrLogic = 35,
    /** ErrConflict defines a conflict error, e.g. when two goroutines try to access the same resource and one of them fails. */
    ErrConflict = 36,
    /** ErrNotSupported is returned when we call a branch of a code which is currently not supported. */
    ErrNotSupported = 37,
    /** ErrNotFound defines an error when requested entity doesn't exist in the state. */
    ErrNotFound = 38,
    /** ErrIO should be used to wrap internal errors caused by external operation. Examples: not DB domain error, file writing etc... */
    ErrIO = 39,
    /** ErrAppConfig defines an error occurred if min-gas-prices field in BaseConfig is empty. */
    ErrAppConfig = 40,
    /** ErrPanic is only set when we recover from a panic, so we know to redact potentially sensitive system info. */
    ErrPanic = 111222
}
//# sourceMappingURL=secret_network_client.d.ts.map