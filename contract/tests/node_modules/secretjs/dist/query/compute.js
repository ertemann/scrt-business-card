"use strict";
// For future wanderers:
// This file is written manually with a few goals in mind:
// 1. Proxy the auto-generated QueryClientImpl from "src/protobuf_stuff/secret/compute/v1beta1/query.tx" (See the "scripts/generate_protobuf.sh" script)
// 2. Abstract "address: Uint8Array" in the underlying types as "address: string".
// 3. Add Secret Network encryption
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToAddress = exports.addressToBytes = exports.ComputeQuerier = void 0;
const encoding_1 = require("@cosmjs/encoding");
const bech32_1 = require("bech32");
const __1 = require("..");
const encryption_1 = require("../encryption");
class ComputeQuerier {
    constructor(grpc, encryption) {
        this.codeHashCache = new Map();
        this.grpc = grpc;
        this.encryption = encryption;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                this.client = new (yield Promise.resolve().then(() => __importStar(require("../protobuf_stuff/secret/compute/v1beta1/query")))).QueryClientImpl(this.grpc);
            }
            if (!this.encryption) {
                this.encryption = new encryption_1.EncryptionUtilsImpl(new (yield Promise.resolve().then(() => __importStar(require("../protobuf_stuff/secret/registration/v1beta1/query")))).QueryClientImpl(this.grpc));
            }
        });
    }
    /** Get codeHash of a Secret Contract */
    contractCodeHash(address) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            let codeHash = this.codeHashCache.get(address);
            if (!codeHash) {
                const { ContractInfo } = yield this.contractInfo(address);
                codeHash = (yield this.codeHash(Number(ContractInfo.codeId)))
                    .replace("0x", "")
                    .toLowerCase();
                this.codeHashCache.set(address, codeHash);
            }
            return codeHash;
        });
    }
    /** Get codeHash from a code id */
    codeHash(codeId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            let codeHash = this.codeHashCache.get(codeId);
            if (!codeHash) {
                const { codeInfo } = yield this.code(codeId);
                codeHash = codeInfo.codeHash;
                this.codeHashCache.set(codeId, codeHash);
            }
            return codeHash;
        });
    }
    /** Get metadata of a Secret Contract */
    contractInfo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            const response = yield this.client.contractInfo({
                address: addressToBytes(address),
            });
            return {
                address: bytesToAddress(response.address),
                ContractInfo: contractInfoFromProtobuf(response.ContractInfo),
            };
        });
    }
    /** Get all contracts that were instantiated from a code id */
    contractsByCode(codeId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            const response = yield this.client.contractsByCode({
                codeId: String(codeId),
            });
            return {
                contractInfos: response.contractInfos.map((x) => ({
                    address: bytesToAddress(x.address),
                    ContractInfo: x.ContractInfo
                        ? contractInfoFromProtobuf(x.ContractInfo)
                        : undefined,
                })),
            };
        });
    }
    /** Query a Secret Contract */
    queryContract({ contractAddress, codeHash, query, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            if (!codeHash) {
                console.warn((0, __1.getMissingCodeHashWarning)("queryContract()"));
                codeHash = yield this.contractCodeHash(contractAddress);
            }
            codeHash = codeHash.replace("0x", "").toLowerCase();
            const encryptedQuery = yield this.encryption.encrypt(codeHash, query);
            const nonce = encryptedQuery.slice(0, 32);
            try {
                const { data: encryptedResult } = yield this.client.smartContractState({
                    address: addressToBytes(contractAddress),
                    queryData: encryptedQuery,
                });
                const decryptedBase64Result = yield this.encryption.decrypt(encryptedResult, nonce);
                return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)((0, encoding_1.fromUtf8)(decryptedBase64Result))));
            }
            catch (err) {
                try {
                    const errorMessageRgx = /encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;
                    const rgxMatches = errorMessageRgx.exec(err.message);
                    if (rgxMatches == null || (rgxMatches === null || rgxMatches === void 0 ? void 0 : rgxMatches.length) != 2) {
                        throw err;
                    }
                    const encryptedError = (0, encoding_1.fromBase64)(rgxMatches[1]);
                    const decryptedBase64Error = yield this.encryption.decrypt(encryptedError, nonce);
                    try {
                        return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)((0, encoding_1.fromUtf8)(decryptedBase64Error))));
                    }
                    catch (parseError) {
                        if (parseError.message === "Invalid base64 string format") {
                            return JSON.parse((0, encoding_1.fromUtf8)(decryptedBase64Error));
                        }
                        else {
                            throw err;
                        }
                    }
                }
                catch (decryptionError) {
                    throw err;
                }
            }
        });
    }
    /** Get WASM bytecode and metadata for a code id */
    code(codeId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            const response = yield this.client.code({ codeId: String(codeId) });
            const codeInfo = codeInfoResponseFromProtobuf(response.codeInfo);
            this.codeHashCache.set(codeId, codeInfo.codeHash.replace("0x", "").toLowerCase());
            return {
                codeInfo,
                data: response.data,
            };
        });
    }
    codes() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            const response = yield this.client.codes({});
            return response.codeInfos.map((codeInfo) => codeInfoResponseFromProtobuf(codeInfo));
        });
    }
}
exports.ComputeQuerier = ComputeQuerier;
function addressToBytes(address) {
    return Uint8Array.from(bech32_1.bech32.fromWords(bech32_1.bech32.decode(address).words));
}
exports.addressToBytes = addressToBytes;
function bytesToAddress(bytes, prefix = "secret") {
    return bech32_1.bech32.encode(prefix, bech32_1.bech32.toWords(bytes));
}
exports.bytesToAddress = bytesToAddress;
function contractInfoFromProtobuf(contractInfo) {
    return {
        codeId: contractInfo.codeId,
        creator: bytesToAddress(contractInfo.creator),
        label: contractInfo.label,
        created: contractInfo.created,
    };
}
function codeInfoResponseFromProtobuf(codeInfo) {
    return codeInfo
        ? {
            codeId: codeInfo.codeId,
            creator: bytesToAddress(codeInfo.creator),
            codeHash: (0, encoding_1.toHex)(codeInfo.dataHash).replace("0x", "").toLowerCase(),
            source: codeInfo.source,
            builder: codeInfo.builder,
        }
        : {
            // This should never happen
            codeId: "",
            creator: "",
            codeHash: "",
            source: "",
            builder: "",
        };
}
//# sourceMappingURL=compute.js.map